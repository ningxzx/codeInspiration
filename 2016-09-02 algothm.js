
/**
 *  Created by Xzx on 16/9/2.
 *  Updated by Xzx on 16/9/3.
 *  自然数，最后一位数字6移到第一位，移动后数字恰好是原数字的3倍，找到这个数字最少是几位数
 *  6*3,原数字倒数第二位是8
 *  6/3,原数字第一位是2
 *  那么原始数字一定是  20***86  的形式;
 *  新数字为  620***8  的形式,从 68 进行逆向推理, 例子: ****86*3 => ****58 ==>  ***586*3  => ***758,etc;
 *  问题简化为,初值为 [6,8],乘以 3 生成新的位数后向前迭代,直至生成尾部为[0,2]的数组,显然[0,2]可以继续迭代达到另一个[0,2],这里寻找最小的数。
 *  因此考虑第一次即可。
 *
 *  history
 *  第一个版本的代码中,没有考虑当a的值大于10时的情况
 *      => 加和大于10时,保留个位,十位累积到下次相加。这也证明第一个版本有另一个误区,迭代的永远是单个数字,而不是上次的加和。而且迭代对象一直是个位数保持了一致性,便于思考。
 *      => 最终解决方案使用了addTemp,很完美,仔细想想,这是大数乘法中必备的做法,最近真是算法接触太少了。
 *  第二个版本的代码中,使用了x.slice(-2,-1)!==0||x.slice(-1)!==2 这样的判别条件,后改成x.slice(-2)==[0,2]
 *      => 简直是令人耻辱啊,slice方法返回的数组,以及,对象互相不等这种常识都忘记了,公司真的是毁人不倦,精力不能淹没在业务逻辑和无意义的情绪中。
 *  第三个版本中,使用了x.slice(-2)[0]!=0||x.slice(-1)[1]!=2 这种丑陋的判断
 *      => 条件应该在每次迭代中诞生,这样也是合乎循环结构的逻辑,仔细分析后,其实是判断上上次的a与上次的a能否满足条件,
 *      => 用一个foreNum保持上次的a,a值更新,在下次循环进来以前正好是最近两次的a。但是在运算是需要用到上一次的a,因此使用了临时变量temp保存foreNum的值。
 *      => 除了变量命名,目前对这个解决方案表示满意。
 *
 **/
let a = 8, x = [6, 8], addTemp = 0, foreNum = 6, temp, floor = Math.floor;
while (foreNum !== 0 || a !== 2) {
    temp = foreNum;
    foreNum = a;
    a = floor(temp * 3 / 10) + a * 3 % 10 + addTemp;
    if (a >= 10) {
        addTemp = floor(a / 10)
        a = a % 10;
    }
    else {
        addTemp = 0;
    }
    x.push(a)
}